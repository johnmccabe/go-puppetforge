/*
 * Puppet Forge v3 API
 *
 * ## Introduction The Puppet Forge API (hereafter referred to as the Forge API) provides quick access to all the data on the Puppet Forge via a RESTful interface. Using the Forge API, you can write scripts and tools that interact with the Puppet Forge website.  The Forge API's current version is `v3`. It is considered regression-stable, meaning that the returned data is guaranteed to include the fields described in the schemas on this page; however, additional data might be added in the future and clients must ignore any properties they do not recognize.  ## OpenAPI Specification The Puppet Forge v3 API is described by an [OpenAPI 3.0](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md) formatted specification file. The most up-to-date version of this specification file can be accessed at [https://forgeapi.puppet.com/v3/openapi.json](/v3/openapi.json).  ## Features * The API is accessed over HTTPS via either the `forgeapi.puppet.com` (IPv4) or `forgeapi-cdn.puppet.com` (IPv4 or IPv6) domain. All data is returned in JSON   format. * Blank fields are included as `null`. * Nested resources may use an abbreviated representation. A link to the full representation for the   resource is always included. * All timestamps in JSON responses are returned in ISO 8601 format: `YYYY-MM-DD HH:MM:SS Â±HHMM`. * The HTTP response headers include caching hints for conditional requests.  ## Concepts and Terminology * **Module**: Modules are self-contained bundles of code and data with a specific directory structure. Modules are identified by a combination of the author's username and the module's name, separated by a hyphen. For example: `puppetlabs-apache` * **Release**: A single, specific version of a module is called a Release. Releases are identified by a combination of the module identifier (see above) and the Release version, separated by a hyphen. For example: `puppetlabs-apache-4.0.0`  ## Errors The Puppet Forge API follows [RFC 2616](https://tools.ietf.org/html/rfc2616) and [RFC 6585](https://tools.ietf.org/html/rfc6585).  Error responses are served with a `4xx` or `5xx` status code, and are sent as a JSON document with a content type of `application/json`. The error document contains the following top-level keys and values:    * `message`: a string value that summarizes the problem   * `errors`: a list (array) of strings containing additional details describing the underlying cause(s) of the     failure  An example error response is shown below:  ```json {   \"message\": \"400 Bad Request\",   \"errors\": [     \"Cannot parse request body as JSON\"   ] } ```  ## User-Agent Required All API requests must include a valid `User-Agent` header. Requests with no `User-Agent` header will be rejected. The `User-Agent` header helps identify your application or library, so we can communicate with you if necessary. If your use of the API is informal or personal, we recommend using your username as the value for the `User-Agent` header.  User-Agent headers are a list of one or more product descriptions, generally taking this form:  ``` <name-without-spaces>/<version> (comments) ```  For example, the following are all useful User-Agent values:  ``` MyApplication/0.0.0 Her/0.6.8 Faraday/0.8.8 Ruby/1.9.3-p194 (i386-linux) My-Library-Name/1.2.4 myusername ```  ## Hostname Configuration Most tools that interact with the Forge API allow specification of the hostname to use. You can configure a few common tools to use a specified hostname as follows:      For **Puppet Enterprise** users, in [r10k](https://puppet.com/docs/pe/latest/r10k_customize_config.html#r10k_configuring_forge_settings) or [Code Manager](https://puppet.com/docs/pe/latest/code_mgr_customizing.html#config_forge_settings), specify `forge_settings` in Hiera: ``` pe_r10k::forge_settings:   baseurl: 'https://forgeapi-cdn.puppet.com' ``` or ``` puppet_enterprise::master::code_manager::forge_settings:   baseurl: 'https://forgeapi-cdn.puppet.com' ``` <br />    If you are an **open source Puppet** user using r10k, you'll need to [edit your r10k.yaml directly](https://github.com/puppetlabs/r10k/blob/master/doc/dynamic-environments/configuration.mkd#forge): ``` forge:   baseurl: 'https://forgeapi-cdn.puppet.com' ``` or set the appropriate class param for the [open source r10k module](https://forge.puppet.com/puppet/r10k#forge_settings): ``` $forge_settings = {   'baseurl' => 'https://forgeapi-cdn.puppet.com', } ``` <br />    In [**Bolt**](https://puppet.com/docs/bolt/latest/bolt_configuration_reference.html#puppetfile-configuration-options), set a `baseurl` for the Forge in `bolt.yaml`: ``` puppetfile:   forge:     baseurl: 'https://forgeapi-cdn.puppet.com' ``` <br />    Using `puppet config`: ``` $ puppet config set module_repository https://forgeapi-cdn.puppet.com ``` 
 *
 * API version: 19
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package puppetforge

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	_bytes "bytes"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// ModuleOperationsApiService ModuleOperationsApi service
type ModuleOperationsApiService service

/*
 * DeleteModule Delete module
 *
 * Perform a soft delete of a module, identified by the module&#39;s &#x60;slug&#x60; value. The module&#39;s releases will still be available for direct download via their associated &#x60;/v3/files&#x60; endpoints, but the module will no longer be readily available through the Forge web interface. 
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moduleSlug Unique textual identifier (slug) of the Module resource to retrieve
 * @param reason Reason for deletion
 */
func (a *ModuleOperationsApiService) DeleteModule(ctx _context.Context, moduleSlug string, reason string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/modules/{module_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"module_slug"+"}", _neturl.PathEscape(parameterToString(moduleSlug, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("reason", parameterToString(reason, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization: Bearer &lt;api_key&gt;"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
 * DeprecateModule Deprecate module
 *
 * Mark a module, identified by the module&#39;s &#x60;slug&#x60; value, as \&quot;deprecated\&quot;. Deprecated modules are still visible on the Forge website, but users are directed to strongly consider alternate modules. **Because the deprecate action is intended to be one-way, there is no operation for undeprecating a module.** 
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moduleSlug Unique textual identifier (slug) of the module to deprecate
 * @param deprecationRequest Action and params for patch operation.
 */
func (a *ModuleOperationsApiService) DeprecateModule(ctx _context.Context, moduleSlug string, deprecationRequest DeprecationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/modules/{module_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"module_slug"+"}", _neturl.PathEscape(parameterToString(moduleSlug, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &deprecationRequest
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization: Bearer &lt;api_key&gt;"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v InlineResponse403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetModuleOpts Optional parameters for the method 'GetModule'
type GetModuleOpts struct {
    WithHtml optional.Bool
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    IfModifiedSince optional.String
}

/*
 * GetModule Fetch module
 *
 * Returns data for a single Module resource identified by the module&#39;s &#x60;slug&#x60; value. 
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moduleSlug Unique textual identifier (slug) of the Module resource to retrieve
 * @param optional nil or *GetModuleOpts - Optional Parameters:
 * @param "WithHtml" (optional.Bool) -  Render markdown files (README, REFERENCE, etc.) to HTML before returning results
 * @param "IncludeFields" (optional.Interface of []string) -  List of top level keys to include in response object, only applies to fields marked 'optional'
 * @param "ExcludeFields" (optional.Interface of []string) -  List of top level keys to exclude from response object
 * @param "IfModifiedSince" (optional.String) - 
 * @return Module
 */
func (a *ModuleOperationsApiService) GetModule(ctx _context.Context, moduleSlug string, localVarOptionals *GetModuleOpts) (Module, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Module
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/modules/{module_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"module_slug"+"}", _neturl.PathEscape(parameterToString(moduleSlug, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.WithHtml.IsSet() {
		localVarQueryParams.Add("with_html", parameterToString(localVarOptionals.WithHtml.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		localVarQueryParams.Add("include_fields", parameterToString(localVarOptionals.IncludeFields.Value(), "ssv"))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		localVarQueryParams.Add("exclude_fields", parameterToString(localVarOptionals.ExcludeFields.Value(), "ssv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfModifiedSince.IsSet() {
		localVarHeaderParams["If-Modified-Since"] = parameterToString(localVarOptionals.IfModifiedSince.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetModulesOpts Optional parameters for the method 'GetModules'
type GetModulesOpts struct {
    Limit optional.Int32
    Offset optional.Int32
    SortBy optional.String
    Query optional.String
    Tag optional.String
    Owner optional.String
    WithTasks optional.Bool
    WithPlans optional.Bool
    WithPdk optional.Bool
    Endorsements optional.Interface
    Operatingsystem optional.String
    PeRequirement optional.String
    PuppetRequirement optional.String
    WithMinimumScore optional.Int32
    ModuleGroups optional.Interface
    ShowDeleted optional.Bool
    HideDeprecated optional.Bool
    OnlyLatest optional.Bool
    Slugs optional.Interface
    WithHtml optional.Bool
    IncludeFields optional.Interface
    ExcludeFields optional.Interface
    IfModifiedSince optional.String
    Supported optional.Bool
}

/*
 * GetModules List modules
 *
 * Returns a list of modules meeting the specified search criteria and filters. Results are paginated. All of the parameters are optional. To publish or delete a Release resource, see [Release operations](#tag/Release-Operations). 
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetModulesOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  The numbers of items to return per page
 * @param "Offset" (optional.Int32) -  The number of items to skip before starting to collect the result set
 * @param "SortBy" (optional.String) -  Desired order in which to return results, note that `rank` is only available (and becomes the default) when a value has been provided for the `query` param 
 * @param "Query" (optional.String) -  Freeform textual search query
 * @param "Tag" (optional.String) -  Constrain results to modules that have the given tag
 * @param "Owner" (optional.String) -  Constrain results to modules owned by the given user
 * @param "WithTasks" (optional.Bool) -  Constrain results to modules that include [Bolt tasks](https://puppet.com/docs/bolt/latest/writing_tasks_and_plans.html) 
 * @param "WithPlans" (optional.Bool) -  Constrain results to modules that include [Bolt plans](https://puppet.com/docs/bolt/latest/writing_tasks_and_plans.html) 
 * @param "WithPdk" (optional.Bool) -  Constrain results to modules created with [Puppet Development Kit](https://puppet.com/docs/pdk/latest/pdk.html) 
 * @param "Endorsements" (optional.Interface of []string) -  Constrain results to modules with at least one of the given endorsements
 * @param "Operatingsystem" (optional.String) -  Constrain results to modules that explicitly support the given operating system, see [metadata.json documentation](https://puppet.com/docs/puppet/latest/modules_metadata.html#specifying-operating-system-compatibility) for more information about possible values, see also the `only_latest` param 
 * @param "PeRequirement" (optional.String) -  Constrain results to modules that explicitly list a Puppet Enterprise version requirement in the given [semantic versioning range](https://puppet.com/docs/puppet/latest/modules_metadata.html#specifying-versions), see also the `only_latest` param 
 * @param "PuppetRequirement" (optional.String) -  Constrain results to modules that explicitly list a Puppet version requirement in the given [semantic versioning range](https://puppet.com/docs/puppet/latest/modules_metadata.html#specifying-versions), see also the `only_latest` param 
 * @param "WithMinimumScore" (optional.Int32) -  Constrain results to modules with at least one release that has a minimum validation_score greater than or equal to the provided integer, see also the `only_latest` param 
 * @param "ModuleGroups" (optional.Interface of []string) -  Constrain results to modules in any of the given module groups
 * @param "ShowDeleted" (optional.Bool) -  Include modules where all released versions have been marked as deleted
 * @param "HideDeprecated" (optional.Bool) -  Exclude deprecated modules from the results. Treats any value as true.
 * @param "OnlyLatest" (optional.Bool) -  When checking modules against the `operatingsystem`, `pe_requirement`, or `puppet_requirement` filters, only consider the compatibility information for the latest release of the module, where \"latest\" means: the module release with the highest precedence, non-pre-release version (see also: [semver.org](https://semver.org/#spec-item-11)) 
 * @param "Slugs" (optional.Interface of []string) -  A comma-separated list of specific modules to retrieve. Module names should be specified in the hyphenated \"slug\" format (`author_name-module_name`). If at least one of the requested modules is not found, this endpoint returns a 404 error, with the slugs of the missing module(s) in the body. This parameter is incompatible with the `endorsements`, `module_groups`, `only_latest`, `operatingsystem`, `owner`, `pe_requirement`, `puppet_requirement`, `query`, `show_deleted`, `hide_deprecated`, `tag`, `with_minimum_score`, `with_pdk`, `with_tasks`, and `with_plans` parameters. These will produce 400 errors when included. Note that any matching soft-deleted modules (modules with no associated releases) will always be included in the results alongside modules with releases. 
 * @param "WithHtml" (optional.Bool) -  Render markdown files (README, REFERENCE, etc.) to HTML before returning results
 * @param "IncludeFields" (optional.Interface of []string) -  List of top level keys to include in response object, only applies to fields marked 'optional'
 * @param "ExcludeFields" (optional.Interface of []string) -  List of top level keys to exclude from response object
 * @param "IfModifiedSince" (optional.String) - 
 * @param "Supported" (optional.Bool) -  Constrain results to [Supported modules](https://forge.puppet.com/supported), see \"endorsements\" param instead 
 * @return InlineResponse2003
 */
func (a *ModuleOperationsApiService) GetModules(ctx _context.Context, localVarOptionals *GetModulesOpts) (InlineResponse2003, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2003
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/modules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortBy.IsSet() {
		localVarQueryParams.Add("sort_by", parameterToString(localVarOptionals.SortBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Owner.IsSet() {
		localVarQueryParams.Add("owner", parameterToString(localVarOptionals.Owner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithTasks.IsSet() {
		localVarQueryParams.Add("with_tasks", parameterToString(localVarOptionals.WithTasks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithPlans.IsSet() {
		localVarQueryParams.Add("with_plans", parameterToString(localVarOptionals.WithPlans.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithPdk.IsSet() {
		localVarQueryParams.Add("with_pdk", parameterToString(localVarOptionals.WithPdk.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Endorsements.IsSet() {
		localVarQueryParams.Add("endorsements", parameterToString(localVarOptionals.Endorsements.Value(), "ssv"))
	}
	if localVarOptionals != nil && localVarOptionals.Operatingsystem.IsSet() {
		localVarQueryParams.Add("operatingsystem", parameterToString(localVarOptionals.Operatingsystem.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeRequirement.IsSet() {
		localVarQueryParams.Add("pe_requirement", parameterToString(localVarOptionals.PeRequirement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PuppetRequirement.IsSet() {
		localVarQueryParams.Add("puppet_requirement", parameterToString(localVarOptionals.PuppetRequirement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithMinimumScore.IsSet() {
		localVarQueryParams.Add("with_minimum_score", parameterToString(localVarOptionals.WithMinimumScore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleGroups.IsSet() {
		localVarQueryParams.Add("module_groups", parameterToString(localVarOptionals.ModuleGroups.Value(), "ssv"))
	}
	if localVarOptionals != nil && localVarOptionals.ShowDeleted.IsSet() {
		localVarQueryParams.Add("show_deleted", parameterToString(localVarOptionals.ShowDeleted.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HideDeprecated.IsSet() {
		localVarQueryParams.Add("hide_deprecated", parameterToString(localVarOptionals.HideDeprecated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnlyLatest.IsSet() {
		localVarQueryParams.Add("only_latest", parameterToString(localVarOptionals.OnlyLatest.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Slugs.IsSet() {
		localVarQueryParams.Add("slugs", parameterToString(localVarOptionals.Slugs.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.WithHtml.IsSet() {
		localVarQueryParams.Add("with_html", parameterToString(localVarOptionals.WithHtml.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFields.IsSet() {
		localVarQueryParams.Add("include_fields", parameterToString(localVarOptionals.IncludeFields.Value(), "ssv"))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeFields.IsSet() {
		localVarQueryParams.Add("exclude_fields", parameterToString(localVarOptionals.ExcludeFields.Value(), "ssv"))
	}
	if localVarOptionals != nil && localVarOptionals.Supported.IsSet() {
		localVarQueryParams.Add("supported", parameterToString(localVarOptionals.Supported.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfModifiedSince.IsSet() {
		localVarHeaderParams["If-Modified-Since"] = parameterToString(localVarOptionals.IfModifiedSince.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineResponse404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
